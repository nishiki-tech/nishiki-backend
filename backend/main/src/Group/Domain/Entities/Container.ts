import {
	Food,
	FoodId,
	IFoodPropsWithoutCreatedAt,
} from "src/Group/Domain/Entities/Food";
import { AggregateRoot, Identifier } from "src/Shared";
import { DomainObjectError } from "src/Shared";
import { Err, Ok, Result } from "result-ts-type";
import { v4 as uuidv4 } from "uuid";
import { isValidUUIDV4 } from "src/Shared/Utils/Validator";

interface IContainerProps {
	name: string;
	foods: Food[];
}

/**
 * default value
 */
const DEFAULT_CONTAINER_NAME = "default container";

/**
 * This class is container class.
 * The name of container must be shorter than equal to 50 and greater than equal 1.
 */
export class Container extends AggregateRoot<string, IContainerProps> {
	static create(
		id: ContainerId,
		props: IContainerProps,
	): Result<Container, ContainerDomainError> {
		if (props.name.length < 1) {
			return Err(new ContainerDomainError("Container name is too short"));
		}
		if (props.name.length > 255) {
			return Err(new ContainerDomainError("Container name is too long"));
		}
		return Ok(new Container(id, props));
	}

	/**
	 * This function should be used when you create a new container.
	 * @param id
	 * @param containerName
	 * @returns
	 */
	static default(
		id: ContainerId,
		containerName?: string,
	): Result<Container, ContainerDomainError> {
		return Container.create(id, {
			name: containerName || DEFAULT_CONTAINER_NAME,
			foods: [],
		});
	}

	get name(): string {
		return this.props.name;
	}

	get foods(): Food[] {
		return this.props.foods;
	}

	/**
	 * Change the name of container.
	 * @param name
	 */
	public changeName(name: string): Result<Container, ContainerDomainError> {
		return Container.create(this.id, {
			...this.props,
			name: name,
		});
	}

	/**
	 * Add food object to the container.
	 * If the food object already exists in the container, return error.
	 * @param food
	 */
	public addFood(food: Food): Result<Container, ContainerDomainError> {
		const matchedFood = this.props.foods.find((f) => f.id === food.id);
		if (matchedFood !== undefined) {
			return Err(
				new ContainerDomainError(
					"The food object already exists in the container",
				),
			);
		}

		const foods = [...this.props.foods, food];
		return Container.create(this.id, {
			...this.props,
			foods: foods,
		});
	}

	/**
	 * Update food object in the container. But the createdAt is not updated.
	 * If the food object doesn't exist in the container, return error.
	 * @param foodId
	 * @param props
	 */
	public updateFood(
		foodId: FoodId,
		props: IFoodPropsWithoutCreatedAt,
	): Result<Container, ContainerDomainError> {
		if (!this.props.foods.find((f) => f.id.equal(foodId))) {
			return Err(
				new ContainerDomainError(
					"The food object doesn't exist in the container",
				),
			);
		}
		const newFoods: Food[] = [];
		for (const food of this.props.foods) {
			if (food.id.equal(foodId)) {
				const updatedFood = Food.create(food.id, {
					...props,
					createdAt: food.createdAt,
				});
				if (!updatedFood.ok) {
					return Err(updatedFood.error);
				}
				newFoods.push(updatedFood.value);
			} else {
				newFoods.push(food);
			}
		}
		return Container.create(this.id, {
			...this.props,
			foods: newFoods,
		});
	}

	/**
	 * Remove food object from the container.
	 * If the food object doesn't exist in the container, return error.
	 * @param foodId
	 */
	public removeFood(foodId: FoodId): Result<Container, ContainerDomainError> {
		const foods = this.props.foods.filter((f) => {
			if (!f.id.equal(foodId)) return true;
		});
		if (foods.length === this.props.foods.length) {
			return Err(
				new ContainerDomainError(
					"The food object doesn't exist in the container",
				),
			);
		}

		return Container.create(this.id, {
			...this.props,
			foods: foods,
		});
	}
}

/**
 * This class is the container's ID.
 */
export class ContainerId extends Identifier<string> {
	/**
	 * the container ID is UUID.
	 * @param id
	 */
	static create(id: string): Result<ContainerId, ContainerIdDomainError> {
		if (!isValidUUIDV4(id)) {
			return Err(new ContainerIdDomainError("Incorrect Container ID pattern"));
		}

		return Ok(new ContainerId(id));
	}

	/**
	 * generate a new container ID.
	 * The ID is generated by the uuid library.
	 * @link https://github.com/uuidjs/uuid
	 */
	static generate(): ContainerId {
		const uuid = uuidv4();
		return new ContainerId(uuid);
	}
}

export class ContainerIdDomainError extends DomainObjectError {}
export class ContainerDomainError extends ContainerIdDomainError {}
