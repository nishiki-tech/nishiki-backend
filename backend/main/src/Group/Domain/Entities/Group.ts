import { ContainerId } from "src/Group/Domain/Entities/Container";
import { AggregateRoot, Identifier } from "src/Shared";
import { DomainObjectError } from "src/Shared";
import { UserId } from "src/User";
import { Err, Ok, Result } from "result-ts-type";
import { v4 as uuidv4 } from "uuid";
import { isValidUUIDV4 } from "src/Shared/Utils/Validator";

interface IGroupProps {
	name: string;
	containerIds: ContainerId[];
	userIds: UserId[];
}

const DEFAULT_GROUP_NAME = "default group";

/**
 * This class is group class.
 * The name of group must be shorter than equal to 255 and greater than equal 1.
 */
export class Group extends AggregateRoot<string, IGroupProps> {
	static default(groupId: GroupId, groupName?: string) {
		return Group.create(groupId, {
			name: groupName || DEFAULT_GROUP_NAME,
			containerIds: [],
			userIds: [],
		});
	}
	static create(
		id: GroupId,
		props: IGroupProps,
	): Result<Group, GroupDomainError> {
		if (props.name.length < 1) {
			return Err(new GroupDomainError("Group name is too short"));
		}
		if (props.name.length > 255) {
			return Err(new GroupDomainError("Group name is too long"));
		}
		return Ok(
			new Group(id, {
				...props,
			}),
		);
	}

	get name(): string {
		return this.props.name;
	}

	get containerIds(): ContainerId[] {
		return this.props.containerIds;
	}

	get userIds(): UserId[] {
		return this.props.userIds;
	}

	/**
	 * Return true value if the user can edit the group.
	 * @param userId
	 * @returns
	 */
	public canEdit(userId: UserId): boolean {
		return this.props.userIds.some((uid) => uid.equal(userId));
	}

	/**
	 * Change the name of group.
	 * @param name
	 */
	public changeName(name: string): Result<Group, GroupDomainError> {
		return Group.create(this.id, {
			...this.props,
			name: name,
		});
	}

	/**
	 * Add containerId to the group.
	 * If the containerId already exists in the group, return error.
	 * @param containerId
	 */
	public addContainerId(
		containerId: ContainerId,
	): Result<Group, GroupDomainError> {
		const matchedContainerId = this.props.containerIds.find((cid) =>
			cid.equal(containerId),
		);

		if (matchedContainerId !== undefined) {
			return Err(
				new GroupDomainError("The containerId already exists in the group"),
			);
		}

		const containerIds = [...this.props.containerIds, containerId];
		return Group.create(this.id, {
			...this.props,
			containerIds: containerIds,
		});
	}

	/**
	 * Remove a related container's ID from the group.
	 * If the containerId doesn't exist in the group, return error.
	 * @param containerId
	 */
	public removeContainer(
		containerId: ContainerId,
	): Result<Group, GroupDomainError> {
		const containerIds = this.props.containerIds.filter(
			(uid) => !uid.equal(containerId),
		);

		if (containerIds.length === this.props.containerIds.length) {
			return Err(
				new GroupDomainError("The container doesn't exist in the group"),
			);
		}

		return Group.create(this.id, {
			...this.props,
			containerIds: containerIds,
		});
	}

	/**
	 * Add userId to the group.
	 * If the userId already exists in the group, return error.
	 * @param userId
	 */
	public addUserId(userId: UserId): Result<Group, GroupDomainError> {
		const matchedUserId = this.props.userIds.find((uid) => uid.equal(userId));
		if (matchedUserId !== undefined) {
			return Err(
				new GroupDomainError("The userId already exists in the group"),
			);
		}

		const userIds = [...this.props.userIds, userId];
		return Group.create(this.id, {
			...this.props,
			userIds: userIds,
		});
	}

	/**
	 * Remove userId from the group.
	 * If the userId doesn't exist in the group, return error.
	 * @param userId
	 */
	public removeUserId(userId: UserId): Result<Group, GroupDomainError> {
		const unmatchedUserIds = this.props.userIds.filter(
			(uid) => !uid.equal(userId),
		);
		if (unmatchedUserIds.length === this.props.userIds.length) {
			return Err(new GroupDomainError("The userId doesn't exist in the group"));
		}

		return Group.create(this.id, {
			...this.props,
			userIds: unmatchedUserIds,
		});
	}
}

/**
 * This class is the group's ID.
 */
export class GroupId extends Identifier<string> {
	/**
	 * the group ID is UUID.
	 * @param id
	 */
	static create(id: string): Result<GroupId, GroupIdDomainError> {
		if (!isValidUUIDV4(id)) {
			return Err(new GroupIdDomainError("Incorrect Group ID pattern"));
		}

		return Ok(new GroupId(id));
	}

	/**
	 * generate a new group ID.
	 * The ID is generated by the uuid library.
	 * @link https://github.com/uuidjs/uuid
	 */
	static generate(): GroupId {
		const uuid = uuidv4();
		return new GroupId(uuid);
	}
}

export class GroupIdDomainError extends DomainObjectError {}
export class GroupDomainError extends GroupIdDomainError {}
